diff --git a/node_modules/whatwg-fetch/dist/fetch.umd.js b/node_modules/whatwg-fetch/dist/fetch.umd.js
index 6c7b313..b26df3e 100644
--- a/node_modules/whatwg-fetch/dist/fetch.umd.js
+++ b/node_modules/whatwg-fetch/dist/fetch.umd.js
@@ -24,7 +24,8 @@
         }
       })(),
     formData: 'FormData' in global,
-    arrayBuffer: 'ArrayBuffer' in global
+    arrayBuffer: 'ArrayBuffer' in global,
+    readableStream: 'ReadableStream' in global
   };
 
   function isDataView(obj) {
@@ -174,6 +175,7 @@
   function fileReaderReady(reader) {
     return new Promise(function(resolve, reject) {
       reader.onload = function() {
+        console.log('whatwg-fetch fileReaderReady onload', { result: reader.result });
         resolve(reader.result);
       };
       reader.onerror = function() {
@@ -190,6 +192,7 @@
   }
 
   function readBlobAsText(blob) {
+    console.log('whatwg-fetch readBlobAsText', {blob});
     var reader = new FileReader();
     var promise = fileReaderReady(reader);
     reader.readAsText(blob);
@@ -220,6 +223,7 @@
     this.bodyUsed = false;
 
     this._initBody = function(body) {
+      console.log('whatwg-fetch Body _initBody', { body });
       /*
         fetch-mock wraps the Response object in an ES6 Proxy to
         provide useful test harness features such as flush. However, on
@@ -237,8 +241,10 @@
       } else if (typeof body === 'string') {
         this._bodyText = body;
       } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
+        console.log('whatwg-fetch Body _initBody is Blob', { body });
         this._bodyBlob = body;
       } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
+        console.log('whatwg-fetch Body _initBody is FormData', { body });
         this._bodyFormData = body;
       } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
         this._bodyText = body.toString();
@@ -248,7 +254,11 @@
         this._bodyInit = new Blob([this._bodyArrayBuffer]);
       } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
         this._bodyArrayBuffer = bufferClone(body);
+      } else if (support.readableStream && ReadableStream.prototype.isPrototypeOf(body)) {
+        this._bodyReadableStream = body;
+        console.log('whatwg-fetch', 'body is ReadableStream');
       } else {
+        console.log('whatwg-fetch', 'body is text (default case)');
         this._bodyText = body = Object.prototype.toString.call(body);
       }
 
@@ -256,6 +266,7 @@
         if (typeof body === 'string') {
           this.headers.set('content-type', 'text/plain;charset=UTF-8');
         } else if (this._bodyBlob && this._bodyBlob.type) {
+          console.log('whatwg-fetch set blob content type', { type: this._bodyBlob.type });
           this.headers.set('content-type', this._bodyBlob.type);
         } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
           this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
@@ -303,13 +314,39 @@
       };
     }
 
-    this.text = function() {
+    this.text = async function() {
+      console.log('whatwg-fetch text()', { blob: this._bodyBlob, arrayBuffer: this._bodyArrayBuffer, formData: this._bodyFormData });
+
       var rejected = consumed(this);
       if (rejected) {
         return rejected
       }
 
+      if (this._bodyReadableStream) {
+        const chunks = [];
+        const reader = this._bodyReadableStream.getReader();
+        const decoder = new TextDecoder();
+
+        const text = await reader.read().then(function readNextChunk({ done, value }) {
+          if (done) {
+            return chunks.reduce((text, buffer) => text + decoder.decode(buffer, { stream: true }), '');
+          }
+
+          chunks.push(value);
+
+          return reader.read().then(readNextChunk);
+        })
+
+        console.log('whatwg-fetch text() stream read', { text });
+
+        await reader.cancel();
+
+        return text;
+      }
+
       if (this._bodyBlob) {
+        console.log('whatwg-fetch text() is blob');
+
         return readBlobAsText(this._bodyBlob)
       } else if (this._bodyArrayBuffer) {
         return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
@@ -349,6 +386,8 @@
     options = options || {};
     var body = options.body;
 
+    console.log('whatwg-fetch Request headers', { headers: options.headers });
+
     if (input instanceof Request) {
       if (input.bodyUsed) {
         throw new TypeError('Already read')
@@ -438,6 +477,8 @@
   Body.call(Request.prototype);
 
   function Response(bodyInit, options) {
+    console.log('whatwg-fetch new Response', {bodyInit, options});
+
     if (!(this instanceof Response)) {
       throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
     }
@@ -451,6 +492,8 @@
     this.statusText = 'statusText' in options ? options.statusText : '';
     this.headers = new Headers(options.headers);
     this.url = options.url || '';
+    // this.body = new ReadableStream(this);
+    this.body = bodyInit;
     this._initBody(bodyInit);
   }
 
@@ -496,33 +539,66 @@
   }
 
   function fetch(input, init) {
+    // console.log('whatwg-fetch', { input, init });
+
     return new Promise(function(resolve, reject) {
       var request = new Request(input, init);
 
-      if (request.signal && request.signal.aborted) {
+      if (request.signal?.aborted) {
         return reject(new exports.DOMException('Aborted', 'AbortError'))
       }
 
       var xhr = new XMLHttpRequest();
 
-      function abortXhr() {
+      const encoder = new TextEncoder();
+      let canceled = false;
+      let responseTextOffset = 0;
+      let readableStreamController;
+      const readableStream = new ReadableStream({
+        start(controller) {
+          readableStreamController = controller;
+        },
+        cancel() {
+          console.log('whatwg-fetch stream canceled');
+          canceled = true;
+          xhr.abort();
+        }
+      });
+
+      function abort() {
+        console.log('whatwg-fetch request aborted');
         xhr.abort();
+        readableStreamController.error(new exports.DOMException('Aborted', 'AbortError'));
+        reject(new exports.DOMException('Aborted', 'AbortError'))
       }
 
+      request.signal?.addEventListener('abort', abort);
+      
+
       xhr.onload = function() {
-        var options = {
-          status: xhr.status,
-          statusText: xhr.statusText,
-          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
-        };
-        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
-        var body = 'response' in xhr ? xhr.response : xhr.responseText;
-        setTimeout(function() {
-          resolve(new Response(body, options));
-        }, 0);
+        console.log('whatwg-fetch xhr on load', {response: xhr.response});
+
+        async function enqueueSingleChunk() {
+          if (xhr.responseType === 'blob') {
+            const bytes = await readBlobAsArrayBuffer(xhr.response);
+
+            // console.log('whatwg-fetch xhr on load enqueueSingleChunk', { bytes });
+
+            readableStreamController.enqueue(bytes);
+          }
+
+          if (xhr.responseType === 'arraybuffer') {
+            readableStreamController.enqueue(new Uint8Array(xhr.response));
+          }
+  
+          readableStreamController.close();
+        }
+
+        enqueueSingleChunk();
       };
 
       xhr.onerror = function() {
+        console.log('fetch xhr ON ERROR');
         setTimeout(function() {
           reject(new TypeError('Network request failed'));
         }, 0);
@@ -534,11 +610,56 @@
         }, 0);
       };
 
-      xhr.onabort = function() {
-        setTimeout(function() {
-          reject(new exports.DOMException('Aborted', 'AbortError'));
-        }, 0);
-      };
+      // xhr.onabort = function() {
+      //   setTimeout(function() {
+      //     reject(new exports.DOMException('Aborted', 'AbortError'));
+      //   }, 0);
+      // };
+
+      xhr.onprogress = function() {
+        console.log('whatwg-fetch xhr.onprogress enter', { response: xhr.response });
+
+        // const uint8Buffer = new Uint8Array(readBlobAsArrayBuffer(xhr.response));
+        // console.log('whatwg-fetch xhr on progress', { uint8Buffer });
+
+        if (canceled || xhr.responseType !== 'text') {
+          return;
+        };
+
+        const chunk = xhr.response.substring(responseTextOffset);
+
+        responseTextOffset = xhr.response.length;
+
+        console.log('whatwg-fetch xhr.onprogress', {responseTextOffset, chunk});
+
+        const buffer = encoder.encode(chunk, { stream: true });
+      
+        readableStreamController.enqueue(buffer);
+      }
+
+      xhr.onreadystatechange = function() {
+        console.log('whatwg-fetch xhr.onreadystatechange enter', { readyState: xhr.readyState });
+
+        if (xhr.readyState === xhr.DONE) {
+          request.signal?.removeEventListener('abort', abort);
+        }
+
+        if (xhr.readyState === xhr.HEADERS_RECEIVED) {
+          var options = {
+            status: xhr.status,
+            statusText: xhr.statusText,
+            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
+          };
+          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
+          // var body = 'response' in xhr ? xhr.response : xhr.responseText;
+  
+          setTimeout(function() {
+            console.log('whatwg-fetch xhr.onreadystatechange resolve fetch promise ', { options });
+
+            resolve(new Response(readableStream, options));
+          }, 0);
+        }
+      }
 
       function fixUrl(url) {
         try {
@@ -556,16 +677,23 @@
         xhr.withCredentials = false;
       }
 
-      if ('responseType' in xhr) {
-        if (support.blob) {
-          xhr.responseType = 'blob';
-        } else if (
-          support.arrayBuffer &&
-          request.headers.get('Content-Type') &&
-          request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
-        ) {
-          xhr.responseType = 'arraybuffer';
-        }
+      // if ('responseType' in xhr) {
+      //   if (support.blob) {
+      //     xhr.responseType = 'blob';
+      //   } else if (
+      //     support.arrayBuffer &&
+      //     request.headers.get('Content-Type') &&
+      //     request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
+      //   ) {
+      //     xhr.responseType = 'arraybuffer';
+      //   }
+      // }
+
+      xhr.responseType = 'arraybuffer';
+      const contentTypeHeader = request.headers?.get('Content-Type');
+
+      if (contentTypeHeader && contentTypeHeader.indexOf('application/octet-stream') !== -1) {
+        xhr.responseType = 'text';
       }
 
       if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
@@ -574,20 +702,23 @@
         });
       } else {
         request.headers.forEach(function(value, name) {
+          console.log('whatwg-fetch xhr setRequestHeader', { value, name });
           xhr.setRequestHeader(name, value);
         });
       }
 
-      if (request.signal) {
-        request.signal.addEventListener('abort', abortXhr);
+      // if (request.signal) {
+      //   request.signal.addEventListener('abort', abortXhr);
 
-        xhr.onreadystatechange = function() {
-          // DONE (success or failure)
-          if (xhr.readyState === 4) {
-            request.signal.removeEventListener('abort', abortXhr);
-          }
-        };
-      }
+      //   xhr.onreadystatechange = function() {
+      //     // DONE (success or failure)
+      //     if (xhr.readyState === xhr.DONE) {
+      //       request.signal.removeEventListener('abort', abortXhr);
+      //     }
+      //   };
+      // }
+
+      console.log('whatwg-fetch before xhr.send', { url: request.url, body: request._bodyInit });
 
       xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
     })
