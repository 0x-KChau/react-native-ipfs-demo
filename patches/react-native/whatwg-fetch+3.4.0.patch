diff --git a/node_modules/whatwg-fetch/dist/fetch.umd.js b/node_modules/whatwg-fetch/dist/fetch.umd.js
index 6c7b313..500e022 100644
--- a/node_modules/whatwg-fetch/dist/fetch.umd.js
+++ b/node_modules/whatwg-fetch/dist/fetch.umd.js
@@ -24,7 +24,8 @@
         }
       })(),
     formData: 'FormData' in global,
-    arrayBuffer: 'ArrayBuffer' in global
+    arrayBuffer: 'ArrayBuffer' in global,
+    readableStream: 'ReadableStream' in global
   };
 
   function isDataView(obj) {
@@ -248,6 +249,9 @@
         this._bodyInit = new Blob([this._bodyArrayBuffer]);
       } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
         this._bodyArrayBuffer = bufferClone(body);
+      } else if (support.readableStream && ReadableStream.prototype.isPrototypeOf(body)) {
+        this._bodyReadableStream = body;
+        this.body = body;
       } else {
         this._bodyText = body = Object.prototype.toString.call(body);
       }
@@ -264,12 +268,31 @@
     };
 
     if (support.blob) {
-      this.blob = function() {
+      this.blob = async function() {
         var rejected = consumed(this);
         if (rejected) {
           return rejected
         }
 
+        if (this._bodyReadableStream) {
+          const chunks = [];
+          const reader = this._bodyReadableStream.getReader();
+
+          const array = await reader.read().then(function readNextChunk({ done, value }) {
+            if (done) {
+              return chunks.reduce((buffer, chunk) => [...buffer, ...chunk], []);
+            }
+
+            chunks.push(value);
+
+            return reader.read().then(readNextChunk);
+          })
+
+          await reader.cancel();
+
+          return new Blob([new Uint8Array(array)]);
+        }
+
         if (this._bodyBlob) {
           return Promise.resolve(this._bodyBlob)
         } else if (this._bodyArrayBuffer) {
@@ -281,12 +304,34 @@
         }
       };
 
-      this.arrayBuffer = function() {
+      this.arrayBuffer = async function() {
+        var rejected = consumed(this);
+        if (rejected) {
+          return rejected
+        }
+
+        if (this._bodyReadableStream) {
+          const chunks = [];
+          const reader = this._bodyReadableStream.getReader();
+
+          const array = await reader.read().then(function readNextChunk({ done, value }) {
+            if (done) {
+              return chunks.reduce((buffer, chunk) => [...buffer, ...chunk], []);
+            }
+
+            chunks.push(value);
+
+            return reader.read().then(readNextChunk);
+          })
+
+          await reader.cancel();
+
+          const view = new Uint8Array(array);
+
+          return view.buffer;
+        }
+
         if (this._bodyArrayBuffer) {
-          var isConsumed = consumed(this);
-          if (isConsumed) {
-            return isConsumed
-          }
           if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
             return Promise.resolve(
               this._bodyArrayBuffer.buffer.slice(
@@ -303,12 +348,32 @@
       };
     }
 
-    this.text = function() {
+    this.text = async function() {
       var rejected = consumed(this);
       if (rejected) {
         return rejected
       }
 
+      if (this._bodyReadableStream) {
+        const chunks = [];
+        const reader = this._bodyReadableStream.getReader();
+        const decoder = new TextDecoder();
+
+        const text = await reader.read().then(function readNextChunk({ done, value }) {
+          if (done) {
+            return chunks.reduce((text, chunk) => text + decoder.decode(chunk, { stream: true }), '');
+          }
+
+          chunks.push(value);
+
+          return reader.read().then(readNextChunk);
+        })
+
+        await reader.cancel();
+
+        return text;
+      }
+
       if (this._bodyBlob) {
         return readBlobAsText(this._bodyBlob)
       } else if (this._bodyArrayBuffer) {
@@ -499,27 +564,51 @@
     return new Promise(function(resolve, reject) {
       var request = new Request(input, init);
 
-      if (request.signal && request.signal.aborted) {
+      if (request.signal?.aborted) {
         return reject(new exports.DOMException('Aborted', 'AbortError'))
       }
 
       var xhr = new XMLHttpRequest();
 
-      function abortXhr() {
+      const encoder = new TextEncoder();
+      let canceled = false;
+      let responseTextOffset = 0;
+      let readableStreamController;
+      const readableStream = new ReadableStream({
+        start(controller) {
+          readableStreamController = controller;
+        },
+        cancel() {
+          canceled = true;
+          xhr.abort();
+        }
+      });
+
+      function abort() {
         xhr.abort();
+        readableStreamController.error(new exports.DOMException('Aborted', 'AbortError'));
+        reject(new exports.DOMException('Aborted', 'AbortError'))
       }
 
+      request.signal?.addEventListener('abort', abort);
+      
+
       xhr.onload = function() {
-        var options = {
-          status: xhr.status,
-          statusText: xhr.statusText,
-          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
-        };
-        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
-        var body = 'response' in xhr ? xhr.response : xhr.responseText;
-        setTimeout(function() {
-          resolve(new Response(body, options));
-        }, 0);
+        async function enqueueSingleChunk() {
+          if (xhr.responseType === 'blob') {
+            const bytes = await readBlobAsArrayBuffer(xhr.response);
+
+            readableStreamController.enqueue(bytes);
+          }
+
+          if (xhr.responseType === 'arraybuffer') {
+            readableStreamController.enqueue(new Uint8Array(xhr.response));
+          }
+  
+          readableStreamController.close();
+        }
+
+        enqueueSingleChunk();
       };
 
       xhr.onerror = function() {
@@ -534,11 +623,39 @@
         }, 0);
       };
 
-      xhr.onabort = function() {
-        setTimeout(function() {
-          reject(new exports.DOMException('Aborted', 'AbortError'));
-        }, 0);
-      };
+      xhr.onprogress = function() {
+        if (canceled || xhr.responseType !== 'text') {
+          return;
+        };
+
+        const chunk = xhr.response.substring(responseTextOffset);
+
+        responseTextOffset = xhr.response.length;
+
+        const buffer = encoder.encode(chunk, { stream: true });
+      
+        readableStreamController.enqueue(buffer);
+      }
+
+      xhr.onreadystatechange = function() {
+        if (xhr.readyState === xhr.DONE) {
+          request.signal?.removeEventListener('abort', abort);
+        }
+
+        if (xhr.readyState === xhr.HEADERS_RECEIVED) {
+          var options = {
+            status: xhr.status,
+            statusText: xhr.statusText,
+            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
+          };
+          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
+          // var body = 'response' in xhr ? xhr.response : xhr.responseText;
+  
+          setTimeout(function() {
+            resolve(new Response(readableStream, options));
+          }, 0);
+        }
+      }
 
       function fixUrl(url) {
         try {
@@ -556,16 +673,11 @@
         xhr.withCredentials = false;
       }
 
-      if ('responseType' in xhr) {
-        if (support.blob) {
-          xhr.responseType = 'blob';
-        } else if (
-          support.arrayBuffer &&
-          request.headers.get('Content-Type') &&
-          request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
-        ) {
-          xhr.responseType = 'arraybuffer';
-        }
+      xhr.responseType = 'arraybuffer';
+      const contentTypeHeader = request.headers?.get('Content-Type');
+
+      if (contentTypeHeader && contentTypeHeader.indexOf('application/octet-stream') !== -1) {
+        xhr.responseType = 'text';
       }
 
       if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
@@ -578,17 +690,6 @@
         });
       }
 
-      if (request.signal) {
-        request.signal.addEventListener('abort', abortXhr);
-
-        xhr.onreadystatechange = function() {
-          // DONE (success or failure)
-          if (xhr.readyState === 4) {
-            request.signal.removeEventListener('abort', abortXhr);
-          }
-        };
-      }
-
       xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
     })
   }
